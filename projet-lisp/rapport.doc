I.Introduction
Avant d’implémenter de nouvelles classes, il a fallu comprendre la classe abstract-enumerator, et les explications avec des exemples pour les autres énumérateur à implémenter...

II.Explication des choix d'implémentation
1/
Le slot initial-list conserve un pointeur vers le début de la liste initiale, tandis que le slot enum-list pointe à la suite de la liste des éléments à dénombrer.

2/
Nous implémentons la fonction make-list-enumerator (l & option cirp) avec le circulaire paramètre optionnel réglé sur T, on obtient un énumérateur qui énumère circulairement une infinité des objets de l.

3/
Le slot init-value contient la valeur initiale tandis que le slot current-value détient l'élément suivant à énumérer. Initialement, la valeur actuelle est la valeur initiale. La fonction f est stocké dans le slot fun apporté par héritage de la classe fun-mixin.
Une variante est un modulo-inductif-enumerator qui a une fonction g supplémentaires à appliquer après la fonction f qui effectue l'étape inductive. G est souvent une sorte de fonction modulo. L’after est utilisé pour init-eumerator et la next-element  afin d’appliquer la fonction modulo.

4/

5/
Il s’agit un nnaire-combinaison-enumerator. Le sous-enumerator est encapsulé dans un memo-enumerator et sera appelé jusqu'à ce qu'un élément satisfaisant p est trouvée ou jusqu'à ce qu'il n’ait plus d’élément.

III.Présentation l'hiérarchie des classes.

IV.Conclusion
